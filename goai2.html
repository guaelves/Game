<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>圍棋 AI（會吃子與防守）</title>
<style>
  html, body {
    margin: 0; padding: 0; height: 100%;
    display: flex; flex-direction: column;
    justify-content: center; align-items: center;
    background-color: #f5deb3;
  }
  canvas { background-color: #F0D9B5; width: 90vmin; height: 90vmin; touch-action: none; }
  #controls { display: flex; flex-wrap: wrap; gap: 10px; margin: 10px 0; font-family: "Noto Sans TC", sans-serif; justify-content: center; }
  #status, #winnerText, #stoneCount { font-family: "Noto Sans TC", sans-serif; font-size: 1.1em; color: #333; margin: 4px 0; }
</style>
</head>
<body>
<canvas id="goBoard"></canvas>
<div id="controls">
  <label>模式：
    <select id="gameMode">
      <option value="single" selected>單人對 AI</option>
      <option value="two">雙人對戰</option>
    </select>
  </label>
  <label>棋盤格數：
    <select id="boardSizeSelect">
      <option value="19">19 路</option>
      <option value="13" selected>13 路</option>
      <option value="9">9 路</option>
    </select>
  </label>
  <button onclick="resetGame()">重新開始</button>
  <button onclick="checkWinner()">🧮 計算勝負</button>
</div>
<div id="status">🟢 黑棋下子中</div>
<div id="stoneCount"></div>
<div id="winnerText"></div>

<script>
let BOARD_SIZE = 13;
let board = [];
let currentPlayer = 1;
let canvas = document.getElementById('goBoard');
let ctx = canvas.getContext('2d');
let CELL_SIZE, STONE_RADIUS;
let lastMove = null;
let isAIMoving = false;

function initBoard(size){
  BOARD_SIZE = size;
  board = Array.from({length: BOARD_SIZE},()=>Array(BOARD_SIZE).fill(0));
  currentPlayer = 1;
  resizeCanvas();
  drawBoard();
  document.getElementById('status').textContent = "🟢 黑棋下子中";
}

function resizeCanvas(){
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  CELL_SIZE = canvas.width / BOARD_SIZE;
  STONE_RADIUS = CELL_SIZE/2 - 2;
  drawBoard();
}
window.addEventListener('resize', resizeCanvas);

function drawBoard(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle = '#000';
  for(let i=0;i<BOARD_SIZE;i++){
    ctx.beginPath();
    ctx.moveTo(CELL_SIZE/2, CELL_SIZE/2+i*CELL_SIZE);
    ctx.lineTo(CELL_SIZE/2+(BOARD_SIZE-1)*CELL_SIZE, CELL_SIZE/2+i*CELL_SIZE);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(CELL_SIZE/2+i*CELL_SIZE, CELL_SIZE/2);
    ctx.lineTo(CELL_SIZE/2+i*CELL_SIZE, CELL_SIZE/2+(BOARD_SIZE-1)*CELL_SIZE);
    ctx.stroke();
  }

  for(let r=0;r<BOARD_SIZE;r++){
    for(let c=0;c<BOARD_SIZE;c++){
      if(board[r][c]!==0){
        ctx.beginPath();
        ctx.arc(CELL_SIZE/2+c*CELL_SIZE, CELL_SIZE/2+r*CELL_SIZE, STONE_RADIUS,0,2*Math.PI);
        ctx.fillStyle = board[r][c]===1?'black':'white';
        ctx.fill();
      }
    }
  }

  if(lastMove){
    let [lr, lc] = lastMove;
    ctx.beginPath();
    ctx.arc(CELL_SIZE/2 + lc*CELL_SIZE, CELL_SIZE/2 + lr*CELL_SIZE, STONE_RADIUS+2, 0, 2*Math.PI);
    ctx.lineWidth = 3; ctx.strokeStyle = 'yellow'; ctx.stroke();
  }

  updateStoneCount();
}

function updateStoneCount(){
  let blackCount=0,whiteCount=0;
  for(let r=0;r<BOARD_SIZE;r++)
    for(let c=0;c<BOARD_SIZE;c++){
      if(board[r][c]===1) blackCount++;
      if(board[r][c]===2) whiteCount++;
    }
  document.getElementById('stoneCount').textContent = `黑棋：${blackCount}　白棋：${whiteCount}`;
}

// === 提子邏輯 ===
function getNeighbors(r,c){
  return [[r-1,c],[r+1,c],[r,c-1],[r,c+1]].filter(([rr,cc])=>
    rr>=0 && cc>=0 && rr<BOARD_SIZE && cc<BOARD_SIZE);
}

function getGroup(r,c){
  let color = board[r][c];
  let group = [], visited = new Set();
  function dfs(rr,cc){
    let key = rr+","+cc;
    if(visited.has(key)) return;
    visited.add(key);
    group.push([rr,cc]);
    for(let [nr,nc] of getNeighbors(rr,cc)){
      if(board[nr][nc]===color) dfs(nr,nc);
    }
  }
  dfs(r,c);
  return group;
}

function countLiberties(group){
  let libs = new Set();
  for(let [r,c] of group){
    for(let [nr,nc] of getNeighbors(r,c)){
      if(board[nr][nc]===0) libs.add(nr+","+nc);
    }
  }
  return libs.size;
}

function removeGroup(group){
  for(let [r,c] of group) board[r][c]=0;
}

function placeStone(r,c,color){
  if(r<0||c<0||r>=BOARD_SIZE||c>=BOARD_SIZE) return false;
  if(board[r][c]!==0) return false;
  board[r][c]=color;
  let opponent = 3-color;
  let captured=false;

  // 檢查對手是否被提
  for(let [nr,nc] of getNeighbors(r,c)){
    if(board[nr][nc]===opponent){
      let g=getGroup(nr,nc);
      if(countLiberties(g)===0){
        removeGroup(g);
        captured=true;
      }
    }
  }

  // 自殺判定（除非吃子）
  let myGroup=getGroup(r,c);
  if(countLiberties(myGroup)===0 && !captured){
    board[r][c]=0;
    return false;
  }

  lastMove=[r,c];
  return true;
}

// === AI 邏輯 ===
function aiMove(){
  isAIMoving=true;
  let possible=[];
  for(let r=0;r<BOARD_SIZE;r++)
    for(let c=0;c<BOARD_SIZE;c++)
      if(board[r][c]===0) possible.push([r,c]);

  let best=null;

  // 1️⃣ 找可以提子的點
  for(let [r,c] of possible){
    board[r][c]=2;
    let ate=false;
    for(let [nr,nc] of getNeighbors(r,c)){
      if(board[nr][nc]===1){
        let g=getGroup(nr,nc);
        if(countLiberties(g)===0){ ate=true; break; }
      }
    }
    board[r][c]=0;
    if(ate){ best=[r,c]; break; }
  }

  // 2️⃣ 若無可吃，找防守點（自己有氣危險）
  if(!best){
    for(let r=0;r<BOARD_SIZE;r++){
      for(let c=0;c<BOARD_SIZE;c++){
        if(board[r][c]===2){
          let g=getGroup(r,c);
          if(countLiberties(g)===1){
            let danger = [...new Set(g.flatMap(([rr,cc])=>getNeighbors(rr,cc).filter(([nr,nc])=>board[nr][nc]===0).map(([nr,nc])=>nr+","+nc)))];
            if(danger.length>0){
              let [dr,dc]=danger[0].split(",").map(Number);
              best=[dr,dc];
              break;
            }
          }
        }
      }
    }
  }

  // 3️⃣ 否則隨機下
  if(!best && possible.length>0)
    best = possible[Math.floor(Math.random()*possible.length)];

  if(best){
    placeStone(best[0],best[1],2);
    drawBoard();
    document.getElementById('status').textContent="🟢 黑棋下子中";
  }
  isAIMoving=false;
}

// === 事件 ===
canvas.addEventListener('click', e=>{
  if(isAIMoving) return;
  let rect=canvas.getBoundingClientRect();
  let x=e.clientX-rect.left, y=e.clientY-rect.top;
  let c=Math.round((x-CELL_SIZE/2)/CELL_SIZE);
  let r=Math.round((y-CELL_SIZE/2)/CELL_SIZE);
  if(placeStone(r,c,1)){
    drawBoard();
    document.getElementById('status').textContent="⚪ AI 思考中...";
    setTimeout(aiMove,300);
  }
});

function resetGame(){
  initBoard(parseInt(document.getElementById('boardSizeSelect').value));
}

function checkWinner(){
  let black=0,white=0;
  for(let r=0;r<BOARD_SIZE;r++)
    for(let c=0;c<BOARD_SIZE;c++){
      if(board[r][c]===1) black++;
      if(board[r][c]===2) white++;
    }
  let winner = black>white ? "黑棋勝" : (white>black ? "白棋勝" : "平手");
  document.getElementById('winnerText').textContent=`結果：黑 ${black}　白 ${white}　→ ${winner}`;
}

initBoard(13);
</script>
</body>
</html>
